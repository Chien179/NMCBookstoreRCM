# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.24.0
# source: rcm.sql
import dataclasses
from typing import AsyncIterator, Iterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc.rcm import models


GET_BOOKS_RCM = """-- name: get_books_rcm \\:many
SELECT u.username,
    b.id,
    r.rating,
    b.name,
    b.price,
    b.author,
    b.publisher,
    b.image,
    b.quantity,
    b.description,
    b.is_deleted,
    string_agg(DISTINCT g.name, ',') AS category
FROM books AS b
    INNER JOIN reviews AS r ON b.id = r.books_id
    INNER JOIN users AS u ON r.username = u.username
    INNER JOIN books_genres AS bg ON b.id = bg.books_id
    INNER JOIN genres AS g ON bg.genres_id = g.id
GROUP BY u.username,
    b.id,
    r.rating,
    b.name,
    b.price,
    b.author,
    b.publisher,
    b.quantity,
    b.image,
    b.description,
    b.is_deleted
"""


@dataclasses.dataclass()
class GetBooksRCMRow:
    username: str
    id: int
    rating: int
    name: str
    price: float
    author: str
    publisher: str
    image: List[str]
    quantity: int
    description: str
    is_deleted: bool
    category: memoryview


GET_REVIEWS_AMOUNT = """-- name: get_reviews_amount \\:one
SELECT COUNT(*) AS amount
FROM books AS b
INNER JOIN reviews AS r ON r.books_id = b.id
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_books_rcm(self) -> Iterator[GetBooksRCMRow]:
        result = self._conn.execute(sqlalchemy.text(GET_BOOKS_RCM))
        for row in result:
            yield GetBooksRCMRow(
                username=row[0],
                id=row[1],
                rating=row[2],
                name=row[3],
                price=row[4],
                author=row[5],
                publisher=row[6],
                image=row[7],
                quantity=row[8],
                description=row[9],
                is_deleted=row[10],
                category=row[11],
            )

    def get_reviews_amount(self) -> Optional[int]:
        row = self._conn.execute(sqlalchemy.text(GET_REVIEWS_AMOUNT)).first()
        if row is None:
            return None
        return row[0]


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_books_rcm(self) -> AsyncIterator[GetBooksRCMRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_BOOKS_RCM))
        async for row in result:
            yield GetBooksRCMRow(
                username=row[0],
                id=row[1],
                rating=row[2],
                name=row[3],
                price=row[4],
                author=row[5],
                publisher=row[6],
                image=row[7],
                quantity=row[8],
                description=row[9],
                is_deleted=row[10],
                category=row[11],
            )

    async def get_reviews_amount(self) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(GET_REVIEWS_AMOUNT))).first()
        if row is None:
            return None
        return row[0]
